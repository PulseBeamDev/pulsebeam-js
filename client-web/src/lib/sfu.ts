// @generated by protobuf-ts 2.10.0
// @generated from protobuf file "sfu.proto" (package "sfu", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// --- Client to Server Messages ---

/**
 * @generated from protobuf message sfu.ClientSubscribePayload
 */
export interface ClientSubscribePayload {
    /**
     * @generated from protobuf field: string mid = 1;
     */
    mid: string; // The client's MID (transceiver slot) to use for this track.
    /**
     * @generated from protobuf field: string remote_track_id = 2;
     */
    remoteTrackId: string; // The application-level ID of the remote track to subscribe to.
}
/**
 * @generated from protobuf message sfu.ClientUnsubscribePayload
 */
export interface ClientUnsubscribePayload {
    /**
     * @generated from protobuf field: string mid = 1;
     */
    mid: string; // The client's MID (transceiver slot) to unsubscribe from.
}
/**
 * ClientMessage encapsulates all possible messages from client to SFU.
 *
 * @generated from protobuf message sfu.ClientMessage
 */
export interface ClientMessage {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "subscribe";
        /**
         * @generated from protobuf field: sfu.ClientSubscribePayload subscribe = 1;
         */
        subscribe: ClientSubscribePayload;
    } | {
        oneofKind: "unsubscribe";
        /**
         * @generated from protobuf field: sfu.ClientUnsubscribePayload unsubscribe = 2;
         */
        unsubscribe: ClientUnsubscribePayload;
    } | {
        oneofKind: undefined;
    };
}
// --- Server to Client Messages ---

/**
 * @generated from protobuf message sfu.TrackInfo
 */
export interface TrackInfo {
    /**
     * @generated from protobuf field: string track_id = 1;
     */
    trackId: string; // The ID of the newly available remote track.
    /**
     * @generated from protobuf field: sfu.TrackKind kind = 2;
     */
    kind: TrackKind; // The kind of track.
    /**
     * @generated from protobuf field: string participant_id = 3;
     */
    participantId: string; // The ID of the participant who published this track.
}
/**
 * @generated from protobuf message sfu.TrackSwitchInfo
 */
export interface TrackSwitchInfo {
    /**
     * @generated from protobuf field: string mid = 2;
     */
    mid: string; // The client's MID that the SFU will use (confirming client's request).
    /**
     * @generated from protobuf field: optional sfu.TrackInfo remote_track = 3;
     */
    remoteTrack?: TrackInfo;
}
/**
 * @generated from protobuf message sfu.TrackPublishedPayload
 */
export interface TrackPublishedPayload {
    /**
     * @generated from protobuf field: repeated sfu.TrackInfo remote_tracks = 1;
     */
    remoteTracks: TrackInfo[];
}
/**
 * @generated from protobuf message sfu.TrackUnpublishedPayload
 */
export interface TrackUnpublishedPayload {
    /**
     * @generated from protobuf field: repeated string remote_track_ids = 1;
     */
    remoteTrackIds: string[]; // The ID of the remote track that is no longer available.
}
/**
 * @generated from protobuf message sfu.TrackSwitchedPayload
 */
export interface TrackSwitchedPayload {
    /**
     * @generated from protobuf field: repeated sfu.TrackSwitchInfo switches = 1;
     */
    switches: TrackSwitchInfo[];
}
/**
 * @generated from protobuf message sfu.ErrorPayload
 */
export interface ErrorPayload {
    /**
     * @generated from protobuf field: string description = 1;
     */
    description: string; // General error message from the SFU.
}
/**
 * ServerMessage encapsulates all possible messages from SFU to client.
 *
 * @generated from protobuf message sfu.ServerMessage
 */
export interface ServerMessage {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "error";
        /**
         * @generated from protobuf field: sfu.ErrorPayload error = 1;
         */
        error: ErrorPayload; // General error from SFU.
    } | {
        oneofKind: "trackPublished";
        /**
         * @generated from protobuf field: sfu.TrackPublishedPayload track_published = 2;
         */
        trackPublished: TrackPublishedPayload; // SFU informs client a new remote track is available.
    } | {
        oneofKind: "trackUnpublished";
        /**
         * @generated from protobuf field: sfu.TrackUnpublishedPayload track_unpublished = 3;
         */
        trackUnpublished: TrackUnpublishedPayload; // SFU informs client a remote track is no longer available.
    } | {
        oneofKind: "trackSwitched";
        /**
         * @generated from protobuf field: sfu.TrackSwitchedPayload track_switched = 4;
         */
        trackSwitched: TrackSwitchedPayload; // SFU confirms track switching for a mid
    } | {
        oneofKind: undefined;
    };
}
/**
 * Represents the kind of media track.
 *
 * @generated from protobuf enum sfu.TrackKind
 */
export enum TrackKind {
    /**
     * @generated from protobuf enum value: TRACK_KIND_UNSPECIFIED = 0;
     */
    TRACK_KIND_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: VIDEO = 1;
     */
    VIDEO = 1,
    /**
     * @generated from protobuf enum value: AUDIO = 2;
     */
    AUDIO = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ClientSubscribePayload$Type extends MessageType<ClientSubscribePayload> {
    constructor() {
        super("sfu.ClientSubscribePayload", [
            { no: 1, name: "mid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remote_track_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClientSubscribePayload>): ClientSubscribePayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mid = "";
        message.remoteTrackId = "";
        if (value !== undefined)
            reflectionMergePartial<ClientSubscribePayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientSubscribePayload): ClientSubscribePayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mid */ 1:
                    message.mid = reader.string();
                    break;
                case /* string remote_track_id */ 2:
                    message.remoteTrackId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientSubscribePayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mid = 1; */
        if (message.mid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mid);
        /* string remote_track_id = 2; */
        if (message.remoteTrackId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remoteTrackId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.ClientSubscribePayload
 */
export const ClientSubscribePayload = new ClientSubscribePayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientUnsubscribePayload$Type extends MessageType<ClientUnsubscribePayload> {
    constructor() {
        super("sfu.ClientUnsubscribePayload", [
            { no: 1, name: "mid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClientUnsubscribePayload>): ClientUnsubscribePayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mid = "";
        if (value !== undefined)
            reflectionMergePartial<ClientUnsubscribePayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientUnsubscribePayload): ClientUnsubscribePayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mid */ 1:
                    message.mid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientUnsubscribePayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mid = 1; */
        if (message.mid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.ClientUnsubscribePayload
 */
export const ClientUnsubscribePayload = new ClientUnsubscribePayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientMessage$Type extends MessageType<ClientMessage> {
    constructor() {
        super("sfu.ClientMessage", [
            { no: 1, name: "subscribe", kind: "message", oneof: "payload", T: () => ClientSubscribePayload },
            { no: 2, name: "unsubscribe", kind: "message", oneof: "payload", T: () => ClientUnsubscribePayload }
        ]);
    }
    create(value?: PartialMessage<ClientMessage>): ClientMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ClientMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientMessage): ClientMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sfu.ClientSubscribePayload subscribe */ 1:
                    message.payload = {
                        oneofKind: "subscribe",
                        subscribe: ClientSubscribePayload.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribe)
                    };
                    break;
                case /* sfu.ClientUnsubscribePayload unsubscribe */ 2:
                    message.payload = {
                        oneofKind: "unsubscribe",
                        unsubscribe: ClientUnsubscribePayload.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).unsubscribe)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sfu.ClientSubscribePayload subscribe = 1; */
        if (message.payload.oneofKind === "subscribe")
            ClientSubscribePayload.internalBinaryWrite(message.payload.subscribe, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sfu.ClientUnsubscribePayload unsubscribe = 2; */
        if (message.payload.oneofKind === "unsubscribe")
            ClientUnsubscribePayload.internalBinaryWrite(message.payload.unsubscribe, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.ClientMessage
 */
export const ClientMessage = new ClientMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackInfo$Type extends MessageType<TrackInfo> {
    constructor() {
        super("sfu.TrackInfo", [
            { no: 1, name: "track_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "enum", T: () => ["sfu.TrackKind", TrackKind] },
            { no: 3, name: "participant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrackInfo>): TrackInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trackId = "";
        message.kind = 0;
        message.participantId = "";
        if (value !== undefined)
            reflectionMergePartial<TrackInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackInfo): TrackInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string track_id */ 1:
                    message.trackId = reader.string();
                    break;
                case /* sfu.TrackKind kind */ 2:
                    message.kind = reader.int32();
                    break;
                case /* string participant_id */ 3:
                    message.participantId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string track_id = 1; */
        if (message.trackId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trackId);
        /* sfu.TrackKind kind = 2; */
        if (message.kind !== 0)
            writer.tag(2, WireType.Varint).int32(message.kind);
        /* string participant_id = 3; */
        if (message.participantId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.participantId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.TrackInfo
 */
export const TrackInfo = new TrackInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackSwitchInfo$Type extends MessageType<TrackSwitchInfo> {
    constructor() {
        super("sfu.TrackSwitchInfo", [
            { no: 2, name: "mid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "remote_track", kind: "message", T: () => TrackInfo }
        ]);
    }
    create(value?: PartialMessage<TrackSwitchInfo>): TrackSwitchInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mid = "";
        if (value !== undefined)
            reflectionMergePartial<TrackSwitchInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackSwitchInfo): TrackSwitchInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mid */ 2:
                    message.mid = reader.string();
                    break;
                case /* optional sfu.TrackInfo remote_track */ 3:
                    message.remoteTrack = TrackInfo.internalBinaryRead(reader, reader.uint32(), options, message.remoteTrack);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackSwitchInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mid = 2; */
        if (message.mid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mid);
        /* optional sfu.TrackInfo remote_track = 3; */
        if (message.remoteTrack)
            TrackInfo.internalBinaryWrite(message.remoteTrack, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.TrackSwitchInfo
 */
export const TrackSwitchInfo = new TrackSwitchInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPublishedPayload$Type extends MessageType<TrackPublishedPayload> {
    constructor() {
        super("sfu.TrackPublishedPayload", [
            { no: 1, name: "remote_tracks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrackInfo }
        ]);
    }
    create(value?: PartialMessage<TrackPublishedPayload>): TrackPublishedPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteTracks = [];
        if (value !== undefined)
            reflectionMergePartial<TrackPublishedPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPublishedPayload): TrackPublishedPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sfu.TrackInfo remote_tracks */ 1:
                    message.remoteTracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackPublishedPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sfu.TrackInfo remote_tracks = 1; */
        for (let i = 0; i < message.remoteTracks.length; i++)
            TrackInfo.internalBinaryWrite(message.remoteTracks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.TrackPublishedPayload
 */
export const TrackPublishedPayload = new TrackPublishedPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackUnpublishedPayload$Type extends MessageType<TrackUnpublishedPayload> {
    constructor() {
        super("sfu.TrackUnpublishedPayload", [
            { no: 1, name: "remote_track_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TrackUnpublishedPayload>): TrackUnpublishedPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteTrackIds = [];
        if (value !== undefined)
            reflectionMergePartial<TrackUnpublishedPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackUnpublishedPayload): TrackUnpublishedPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string remote_track_ids */ 1:
                    message.remoteTrackIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackUnpublishedPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string remote_track_ids = 1; */
        for (let i = 0; i < message.remoteTrackIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.remoteTrackIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.TrackUnpublishedPayload
 */
export const TrackUnpublishedPayload = new TrackUnpublishedPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackSwitchedPayload$Type extends MessageType<TrackSwitchedPayload> {
    constructor() {
        super("sfu.TrackSwitchedPayload", [
            { no: 1, name: "switches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrackSwitchInfo }
        ]);
    }
    create(value?: PartialMessage<TrackSwitchedPayload>): TrackSwitchedPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.switches = [];
        if (value !== undefined)
            reflectionMergePartial<TrackSwitchedPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackSwitchedPayload): TrackSwitchedPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sfu.TrackSwitchInfo switches */ 1:
                    message.switches.push(TrackSwitchInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackSwitchedPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sfu.TrackSwitchInfo switches = 1; */
        for (let i = 0; i < message.switches.length; i++)
            TrackSwitchInfo.internalBinaryWrite(message.switches[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.TrackSwitchedPayload
 */
export const TrackSwitchedPayload = new TrackSwitchedPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorPayload$Type extends MessageType<ErrorPayload> {
    constructor() {
        super("sfu.ErrorPayload", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorPayload>): ErrorPayload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<ErrorPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorPayload): ErrorPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.ErrorPayload
 */
export const ErrorPayload = new ErrorPayload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerMessage$Type extends MessageType<ServerMessage> {
    constructor() {
        super("sfu.ServerMessage", [
            { no: 1, name: "error", kind: "message", oneof: "payload", T: () => ErrorPayload },
            { no: 2, name: "track_published", kind: "message", oneof: "payload", T: () => TrackPublishedPayload },
            { no: 3, name: "track_unpublished", kind: "message", oneof: "payload", T: () => TrackUnpublishedPayload },
            { no: 4, name: "track_switched", kind: "message", oneof: "payload", T: () => TrackSwitchedPayload }
        ]);
    }
    create(value?: PartialMessage<ServerMessage>): ServerMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ServerMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerMessage): ServerMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sfu.ErrorPayload error */ 1:
                    message.payload = {
                        oneofKind: "error",
                        error: ErrorPayload.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).error)
                    };
                    break;
                case /* sfu.TrackPublishedPayload track_published */ 2:
                    message.payload = {
                        oneofKind: "trackPublished",
                        trackPublished: TrackPublishedPayload.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).trackPublished)
                    };
                    break;
                case /* sfu.TrackUnpublishedPayload track_unpublished */ 3:
                    message.payload = {
                        oneofKind: "trackUnpublished",
                        trackUnpublished: TrackUnpublishedPayload.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).trackUnpublished)
                    };
                    break;
                case /* sfu.TrackSwitchedPayload track_switched */ 4:
                    message.payload = {
                        oneofKind: "trackSwitched",
                        trackSwitched: TrackSwitchedPayload.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).trackSwitched)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sfu.ErrorPayload error = 1; */
        if (message.payload.oneofKind === "error")
            ErrorPayload.internalBinaryWrite(message.payload.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sfu.TrackPublishedPayload track_published = 2; */
        if (message.payload.oneofKind === "trackPublished")
            TrackPublishedPayload.internalBinaryWrite(message.payload.trackPublished, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sfu.TrackUnpublishedPayload track_unpublished = 3; */
        if (message.payload.oneofKind === "trackUnpublished")
            TrackUnpublishedPayload.internalBinaryWrite(message.payload.trackUnpublished, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sfu.TrackSwitchedPayload track_switched = 4; */
        if (message.payload.oneofKind === "trackSwitched")
            TrackSwitchedPayload.internalBinaryWrite(message.payload.trackSwitched, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sfu.ServerMessage
 */
export const ServerMessage = new ServerMessage$Type();
